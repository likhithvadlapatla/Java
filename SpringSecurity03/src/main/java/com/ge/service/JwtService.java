package com.ge.service;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.springframework.stereotype.Service;

import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import java.security.Key;
import java.util.Base64;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

@Service
public class JwtService {

    /*
        Key Generation:
        KeyGenerator.getInstance("HmacSHA256"): This line creates a KeyGenerator instance for the HMAC-SHA256 algorithm.
        HMAC-SHA256 is a type of cryptographic algorithm used to generate a secure hash-based message authentication code (HMAC) using the SHA-256 hash function.

        key.generateKey(): This method generates a new secret key for the HMAC-SHA256 algorithm.

        secretKey.getEncoded(): This retrieves the encoded format of the secret key. It is typically a byte array representing the key.

        Encoding the Key:
        Base64.getEncoder().encodeToString(secretKey.getEncoded()): This line encodes the byte array of the secret key into a Base64 string.

        Base64 Encoding: Converts binary data into an ASCII string format. This is useful for displaying or transmitting binary data in a text format.
     */

    /*
        The Role of the Secret Key
        Creating the Token:
        When you create a JWT, you use a secret key to sign it. This means that you combine the token's data (the payload) with the secret key using a specific algorithm (like HMAC-SHA256).
        Why? This signature helps to ensure that the token is authentic and hasn't been changed since it was created.

        Verifying the Token:
        When someone receives a JWT, they need to check if the token is valid. To do this, they use the same secret key that was used to sign the token.
        How? They recalculate the signature using the received token's data and the secret key. If this recalculated signature matches the one in the token, it confirms that the token hasn’t been altered and was generated by someone who knows the secret key.

        How: The secret key is used to create a unique signature for the token. If someone alters the token, the signature will no longer match, and the token can be identified as tampered.
     */

    public String getTheSecretKey(){
        try{
            KeyGenerator key = KeyGenerator.getInstance("HmacSHA256");
            SecretKey secretKey = key.generateKey();
            return Base64.getEncoder().encodeToString(secretKey.getEncoded());
        }
        catch(Exception e){
            throw new RuntimeException("Error in generating key");
        }
    }

    /*
        Claims Creation:
        Map<String, Object> claims = new HashMap<>();: Creates an empty map to hold claims for the JWT.
        Claims are pieces of information stored in the JWT. They can include user roles, permissions, or any other data you want to include.

        JWT Building:
        Jwts.builder(): Starts building the JWT using the JJWT library.

        setClaims(claims): Sets the claims for the JWT. In this case, it’s an empty map, but you can add more data to it if needed.

        setSubject(name): Sets the subject of the JWT. The subject typically represents the user or entity for whom the token is issued. Here, name is used as the subject.

        setIssuedAt(new Date(System.currentTimeMillis())): Sets the issued-at date for the JWT, indicating when the token was created.
        new Date(System.currentTimeMillis()): Creates a Date object for the current time.

        setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 5)): Sets the expiration date for the JWT, indicating when the token should expire.
        new Date(System.currentTimeMillis() + 1000 * 60 * 5): Adds 5 minutes (300,000 milliseconds) to the current time to set the expiration date.

        signWith(getKey(), SignatureAlgorithm.HS256): Signs the JWT with a secret key using the HMAC SHA-256 algorithm (HS256).
        getKey(): This method should return a SecretKey used for signing the token. It ensures the token’s integrity and authenticity.
        compact(): Finalizes the JWT and returns it as a compact, URL-safe string.
     */

    /*
        About Algorithms:
        Both methods involve the HMAC-SHA256 algorithm. The getTheSecretKey method uses HmacSHA256 to generate the key, and the generateToken method uses SignatureAlgorithm.HS256 (which is based on HMAC-SHA256) to sign the token.
        Signing a JWT (JSON Web Token) means applying a cryptographic algorithm to the token's data (header and payload) using a secret key. This process creates a signature that ensures the token's authenticity and integrity. Here’s a clear breakdown of what it means to "sign" a token:
     */

    /*
        JWT Token :

        Header :
            {
              "alg": "HS256",
              "typ": "JWT"
            }

        Payload :
            {
              "sub": "1234567890",
              "name": "John Doe",
              "admin": true,
              "exp": 1716215580
            }

        This Payload will be combined :
            <encoded-header>.<encoded-payload>

        Signature :
            Use HMAC-SHA256 with the secret key to hash this combined string. For example, if the secret key is your-256-bit-secret, the signature is:
            HMAC-SHA256(<encoded-header>.<encoded-payload>, your-256-bit-secret)

            The final JWT might look like:
            <encoded-header>.<encoded-payload>.<signature>
     */

    public String generateToken(String name){
        Map<String, Object> claims = new HashMap<>();
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(name)
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis()+1000*60*5))
                .signWith(getKey(), SignatureAlgorithm.HS256).compact();

    }

    /*
        Decode Base64 Key:
        Decoders.BASE64.decode(getTheSecretKey()):
        getTheSecretKey(): This method is expected to return a Base64-encoded string representing your secret key.
        Decoders.BASE64.decode(...): This decodes the Base64-encoded string into a byte array (byte[] b). This is necessary because the JWT library needs the key in its raw byte form to use it for cryptographic operations.

        Create HMAC-SHA Key:
        Keys.hmacShaKeyFor(b):
        Keys.hmacShaKeyFor(...): This is a utility method provided by the JJWT library that creates a Key object from the byte array. It’s specifically designed for HMAC algorithms like HMAC-SHA256.
        The method ensures that the Key object is suitable for use with HMAC-SHA256 or other HMAC algorithms.
     */
    private Key getKey(){
        byte[] b = Decoders.BASE64.decode(getTheSecretKey());
        return Keys.hmacShaKeyFor(b);
    }
}
